/*
Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <assert.h>
#include <time.h>
#include <emmintrin.h>

#define UBYTE_TO_CHAN(b)  (b)
#define CHAN_MAX 255

typedef uint8_t byte;
typedef uint32_t dword;
typedef uint64_t uint64;

//------------------------------------------------------------------------------------
//                       Decompression
//------------------------------------------------------------------------------------

void fetch_2d_texel_rgba_ati2(const unsigned char *data, int width, int i, int j, void *texel) {
    unsigned char *rg = (unsigned char *) texel;
    unsigned char *blksrc = (unsigned char *)(data + ((width + 3) / 4 * (j / 4) + (i / 4)) * 16);
    unsigned char alpha0 = blksrc[0];
    unsigned char alpha1 = blksrc[1];
    unsigned char bit_pos = ((j&3) * 4 + (i&3)) * 3;
    unsigned char acodelow = blksrc[2 + bit_pos / 8];
    unsigned char acodehigh = blksrc[3 + bit_pos / 8];
    unsigned char code = (acodelow >> (bit_pos & 0x7) | (acodehigh  << (8 - (bit_pos & 0x7)))) & 0x7;
    if (code == 0)
        rg[0] = UBYTE_TO_CHAN( alpha0 );
    else if (code == 1)
        rg[0] = UBYTE_TO_CHAN( alpha1 );
    else if (alpha0 > alpha1)
        rg[0] = UBYTE_TO_CHAN( ((alpha0 * (8 - code) + (alpha1 * (code - 1))) / 7) );
    else if (code < 6)
        rg[0] = UBYTE_TO_CHAN( ((alpha0 * (6 - code) + (alpha1 * (code - 1))) / 5) );
    else if (code == 6)
        rg[0] = 0;
    else
        rg[0] = CHAN_MAX;

    blksrc += 8;
    alpha0 = blksrc[0];
    alpha1 = blksrc[1];
    bit_pos = ((j&3) * 4 + (i&3)) * 3;
    acodelow = blksrc[2 + bit_pos / 8];
    acodehigh = blksrc[3 + bit_pos / 8];
    code = (acodelow >> (bit_pos & 0x7) | (acodehigh  << (8 - (bit_pos & 0x7)))) & 0x7;
    if (code == 0)
        rg[1] = UBYTE_TO_CHAN( alpha0 );
    else if (code == 1)
        rg[1] = UBYTE_TO_CHAN( alpha1 );
    else if (alpha0 > alpha1)
        rg[1] = UBYTE_TO_CHAN( ((alpha0 * (8 - code) + (alpha1 * (code - 1))) / 7) );
    else if (code < 6)
        rg[1] = UBYTE_TO_CHAN( ((alpha0 * (6 - code) + (alpha1 * (code - 1))) / 5) );
    else if (code == 6)
        rg[1] = 0;
    else
        rg[1] = CHAN_MAX;
}

//------------------------------------------------------------------------------------
//                                 DDS reader
//------------------------------------------------------------------------------------

struct DdsPixelformat {
  dword dwSize;
  dword dwFlags;
  dword dwFourCC;
  dword dwRGBBitCount;
  dword dwRBitMask;
  dword dwGBitMask;
  dword dwBBitMask;
  dword dwABitMask;
};
struct DdsHeader {
  dword           dwSize;
  dword           dwFlags;
  dword           dwHeight;
  dword           dwWidth;
  dword           dwPitchOrLinearSize;
  dword           dwDepth;
  dword           dwMipMapCount;
  dword           dwReserved1[11];
  struct DdsPixelformat  ddspf;
  dword           dwCaps;
  dword           dwCaps2;
  dword           dwCaps3;
  dword           dwCaps4;
  dword           dwReserved2;
};
enum DdsFlags {
    DDSF_CAPS           = 0x00000001,
    DDSF_HEIGHT         = 0x00000002,
    DDSF_WIDTH          = 0x00000004,
    DDSF_PIXELFORMAT    = 0x00001000,
    DDSF_MIPMAPCOUNT    = 0x00020000,
    DDSF_LINEARSIZE     = 0x00080000,
    DDSF_FOURCC         = 0x00000004,
    DDSF_COMPLEX        = 0x00000008,
    DDSF_TEXTURE        = 0x00001000,
    DDSF_MIPMAP         = 0x00400000,
};

byte* ReadDDS(const char *filename, int *width, int *height, int *type) {
    FILE *fin = fopen(filename, "rb");
    assert(fin);

    char *signature = malloc(4);
    fread(signature, 4, 1, fin);

    struct DdsHeader ddsheader;
    fread(&ddsheader, sizeof(struct DdsHeader), 1, fin);

    *width = ddsheader.dwWidth;
    *height = ddsheader.dwHeight;
    if(memcmp(&ddsheader.ddspf.dwFourCC, "ATI1", 4) == 0)
        *type = 1;
    else if(memcmp(&ddsheader.ddspf.dwFourCC, "ATI2", 4) == 0)
        *type = 2;
    byte *data = (byte*)malloc(*width * *height * 2);

    fread(data, ddsheader.dwPitchOrLinearSize, 1, fin);

    fclose(fin);
    return data;
}

//------------------------------------------------------------------------------------
//                                 TGA writer
//------------------------------------------------------------------------------------

#pragma pack(push, 1)
typedef struct TgaImageSpecs {
    uint16_t originX;
    uint16_t originY;
    uint16_t width;
    uint16_t height;
    uint8_t bpp;
    uint8_t desc;
} TgaImageSpecs;
typedef struct TgaHeader {
    uint8_t identificationLength;
    uint8_t colorMapType;
    uint8_t imageTypeCode;
    char colorMapSpecs[5];
    TgaImageSpecs imageSpecs; 
} TgaHeader;
#pragma pack(pop)

void WriteTGA(const char *filename, byte *texel, int width, int height){
   FILE *fout = fopen(filename, "wb");
   assert(fout);

   TgaHeader tgaHeader;
   tgaHeader.identificationLength = 0;
   tgaHeader.colorMapType = 0;
   tgaHeader.imageTypeCode = 2;
   tgaHeader.colorMapSpecs[0] = 0;
   tgaHeader.colorMapSpecs[1] = 0;
   tgaHeader.colorMapSpecs[2] = 0;
   tgaHeader.colorMapSpecs[3] = 0;
   tgaHeader.colorMapSpecs[4] = 0;
   tgaHeader.imageSpecs.originX = 0;
   tgaHeader.imageSpecs.originY = 0;
   tgaHeader.imageSpecs.bpp = 32;
   tgaHeader.imageSpecs.desc = 0X08;
   tgaHeader.imageSpecs.width = width;
   tgaHeader.imageSpecs.height = height;
   fwrite(&tgaHeader, sizeof(TgaHeader), 1, fout);

   int bpp = tgaHeader.imageSpecs.bpp / 8;
   fwrite(texel, width * height * bpp, 1, fout);

   fclose(fout);
}

//------------------------------------------------------------------------------------
//                                 entry point
//------------------------------------------------------------------------------------

int main() {
    int width;
    int height;
    int type;

    byte *data = ReadDDS("test_pics\\container2_RGBA_RGTC_encoded.dds", &width, &height, &type);

    byte *texel = (byte*)malloc(width * height * 4);
    byte *texel_tmp = texel;

    int tmp;
    int startTime = clock();
    for(int j=0; j<height; j++)
        for(int i=0; i<width; i++){
            fetch_2d_texel_rgba_ati2(data, width, i, j, texel_tmp);
            texel_tmp[2] = texel_tmp[0];
            texel_tmp[0] = 0;
            texel_tmp[3] = 0;
            /*tmp = texel_tmp[2];
            texel_tmp[2] = texel_tmp[0];
            texel_tmp[0] = tmp;*/
            texel_tmp = texel_tmp + 4;
        }
    int deltaTime = clock() - startTime;

    WriteTGA("test_pics\\container2_RGBA_RGTC_decoded.tga", texel, width, height);

    printf("Running code took %0.2lf milliseconds\n", 1e+3 * deltaTime / CLOCKS_PER_SEC);

    return 0;
}
